using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using PartialCraft.CSharp.ContextFilters;
using PartialCraft.CSharp.Interfaces;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace PartialCraft.CSharp.CodeWeavers;

public abstract class ClassEntry : ICodeWeaver<ClassDeclarationSyntax, INamedTypeSymbol>
{
    public ClassDeclarationSyntax? Syntax { get; protected set; }
    public INamedTypeSymbol? Symbol { get; protected set; }
    public List<ClassDeclarationSyntax> OuterClasses { get; protected set; } = [];
    public SyntaxFilter<ClassDeclarationSyntax, INamedTypeSymbol> SyntaxFilter => new();
    public SymbolFilter<ClassDeclarationSyntax, INamedTypeSymbol> SymbolFilter => new();

    public virtual void Initialize(ClassDeclarationSyntax classDeclaration, INamedTypeSymbol namedTypeSymbol)
    {
        Syntax = classDeclaration;
        Symbol = namedTypeSymbol;
        OuterClasses = [];
        var parent = classDeclaration.Parent;
        while (parent is ClassDeclarationSyntax outerClass)
        {
            OuterClasses.Insert(0, outerClass);
            parent = parent.Parent;
        }
    }
    
    public virtual string Weave()
    {
        if (Syntax == null || Symbol == null) return string.Empty;

        StringBuilder sourceBuilder = new();
        int currentIndentLevel = 0;

        sourceBuilder.AppendLine("// <auto-generated>");
        sourceBuilder.AppendLine("#pragma warning disable");
        sourceBuilder.AppendLine("#nullable enable");
        sourceBuilder.AppendLine();

        int currentClassDepth = 0;

        if (OuterClasses.Count > 0)
        {
            sourceBuilder.AppendLine($"namespace {Symbol.ContainingNamespace};");
            sourceBuilder.AppendLine();

            for (int i = 0; i < OuterClasses.Count; i++)
            {
                var outerClass = OuterClasses[i];
                var modifiers = outerClass.Modifiers.ToString();

                sourceBuilder.AppendIndentedLine(currentClassDepth, $"{modifiers} class {outerClass.Identifier.Text}");
                sourceBuilder.AppendIndentedLine(currentClassDepth, "{");

                currentIndentLevel++;
            }
        }

        var baseTypes = GenerateBaseTypes();
        var baseInterfaces = GenerateBaseInterfaces();
        var inheritanceSymbol = (baseTypes.Length + baseInterfaces.Length) > 0 ? ":" : string.Empty;

        currentClassDepth++;

        var currentModifiers = Syntax.Modifiers.ToString();
        sourceBuilder.AppendIndentedLine(currentClassDepth, $"{currentModifiers} class {Syntax.Identifier.Text} {inheritanceSymbol} {string.Join(", ", baseTypes.Concat(baseInterfaces))}");
        sourceBuilder.AppendIndentedLine(currentClassDepth, "{");

        currentIndentLevel++;

        var bodyContent = GenerateBody(currentClassDepth);
        if (!string.IsNullOrEmpty(bodyContent))
        {
            var bodyLines = bodyContent.Split('\n');
            foreach (var line in bodyLines)
            {
                var trimmedLine = line.TrimEnd('\r', '\n');
                sourceBuilder.AppendIndentedLine(
                    currentClassDepth,
                    string.IsNullOrEmpty(trimmedLine) ? string.Empty : trimmedLine);
            }
        }

        currentIndentLevel--;
        sourceBuilder.AppendIndentedLine(currentClassDepth, "}");

        currentClassDepth--;

        if (OuterClasses.Count > 0)
        {
            for (int i = 0; i < OuterClasses.Count; i++)
            {
                currentIndentLevel--;
                sourceBuilder.AppendIndentedLine(currentClassDepth, "}");
            }
        }

        return sourceBuilder.ToString();
    }
    
    public abstract string GetFileName();
    public virtual bool CanWeave() => true;
    public virtual Encoding GetEncoding() => Encoding.UTF8;
    protected abstract string[] GenerateBaseTypes();
    protected abstract string[] GenerateBaseInterfaces();
    protected abstract string GenerateBody(int depth);
}